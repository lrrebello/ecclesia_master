
===== config.py =====

import os
from datetime import timedelta
from dotenv import load_dotenv

# Carrega as variáveis do arquivo .env
load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-key-ecclesia-2026'
    
    # Suporte dinâmico para PostgreSQL ou SQLite
    # No Heroku/Render, a variável DATABASE_URL é preenchida automaticamente
    database_url = os.environ.get('DATABASE_URL')
    if database_url and database_url.startswith("postgres://"):
        database_url = database_url.replace("postgres://", "postgresql://", 1)
    
    SQLALCHEMY_DATABASE_URI = database_url or 'sqlite:///ecclesia.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    REMEMBER_COOKIE_DURATION = timedelta(days=30)
    UPLOAD_FOLDER = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'app/static/uploads')
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB
    
    # Configurações de E-mail (SMTP)
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.gmail.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', 587))
    MAIL_USE_TLS = True
    MAIL_USE_SSL = False
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER', MAIL_USERNAME)

===== __init__.py =====

# Arquivo completo: app/__init__.py
from flask import Flask, render_template, request, current_app
from flask_login import LoginManager, current_user
from flask_mail import Mail
from app.core.models import db, User, Event, Ministry, Media
from config import Config
from datetime import datetime

login_manager = LoginManager()
mail = Mail()

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    
    db.init_app(app)
    login_manager.init_app(app)
    mail.init_app(app)
    login_manager.login_view = 'auth.login'
    
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))
    
    # Blueprints - Importações dentro da função para evitar ciclos
    from app.modules.auth.routes import auth_bp
    from app.modules.members.routes import members_bp
    from app.modules.finance.routes import finance_bp
    from app.modules.finance.modelo25 import modelo25_bp
    from app.modules.edification.routes import edification_bp
    from app.modules.admin.routes import admin_bp
    
    app.register_blueprint(auth_bp)
    app.register_blueprint(members_bp, url_prefix='/members')
    app.register_blueprint(finance_bp, url_prefix='/finance')
    app.register_blueprint(modelo25_bp)
    app.register_blueprint(edification_bp, url_prefix='/edification')
    app.register_blueprint(admin_bp, url_prefix='/admin')

    import json
    @app.template_filter('from_json')
    def from_json_filter(value):
        if not value:
            return {}
        try:
            return json.loads(value)
        except (ValueError, TypeError):
            return {}

    # Rota inicial
    @app.route('/')
    def index():
        return render_template('index.html')

    # Context Processors
    @app.context_processor
    def inject_public_events():
        if current_user.is_authenticated:
            public_events = Event.query.filter(Event.ministry_id.is_(None), Event.church_id == current_user.church_id).order_by(Event.start_time.asc()).limit(5).all()
        else:
            public_events = Event.query.filter(Event.ministry_id.is_(None)).order_by(Event.start_time.asc()).limit(5).all()
        return dict(public_events=public_events)

    @app.context_processor
    def inject_is_ministry_leader():
        def is_ministry_leader(ministry_id):
            ministry = Ministry.query.get(ministry_id)
            return ministry and ministry.leader_id == current_user.id
        return dict(is_ministry_leader=is_ministry_leader)

    @app.context_processor
    def inject_public_media():
        if current_user.is_authenticated:
            public_media = Media.query.filter_by(church_id=current_user.church_id, ministry_id=None).order_by(Media.created_at.desc()).limit(5).all()
        else:
            public_media = Media.query.filter(Media.ministry_id.is_(None)).order_by(Media.created_at.desc()).limit(5).all()
        return dict(public_media=public_media)

    return app
